{
  "version": 3,
  "sources": ["../../convex/src/server/api.ts", "../../convex/src/common/index.ts", "../../convex/src/values/base64.ts", "../../convex/src/values/value.ts", "../../convex/src/values/validator.ts", "../../convex/src/values/errors.ts", "../../convex/src/index.ts"],
  "sourcesContent": ["import {\n  EmptyObject,\n  DefaultFunctionArgs,\n  FunctionVisibility,\n  RegisteredAction,\n  RegisteredMutation,\n  RegisteredQuery,\n} from \"./registration.js\";\nimport { Expand, UnionToIntersection } from \"../type_utils.js\";\nimport { PaginationOptions, PaginationResult } from \"./pagination.js\";\n\n/**\n * The type of a Convex function.\n *\n * @public\n */\nexport type FunctionType = \"query\" | \"mutation\" | \"action\";\n\n/**\n * A reference to a registered Convex function.\n *\n * You can create a {@link FunctionReference} using the generated `api` utility:\n * ```js\n * import { api } from \"../convex/_generated/api\";\n *\n * const reference = api.myModule.myFunction;\n * ```\n *\n * If you aren't using code generation, you can create references using\n * {@link anyApi}:\n * ```js\n * import { anyApi } from \"convex/server\";\n *\n * const reference = anyApi.myModule.myFunction;\n * ```\n *\n * Function references can be used to invoke functions from the client. For\n * example, in React you can pass references to the {@link react.useQuery} hook:\n * ```js\n * const result = useQuery(api.myModule.myFunction);\n * ```\n *\n * @typeParam Type - The type of the function (\"query\", \"mutation\", or \"action\").\n * @typeParam Visibility - The visibility of the function (\"public\" or \"internal\").\n * @typeParam Args - The arguments to this function. This is an object mapping\n * argument names to their types.\n * @typeParam ReturnType - The return type of this function.\n * @public\n */\nexport type FunctionReference<\n  Type extends FunctionType,\n  Visibility extends FunctionVisibility = \"public\",\n  Args extends DefaultFunctionArgs = any,\n  ReturnType = any\n> = {\n  _type: Type;\n  _visibility: Visibility;\n  _args: Args;\n  _returnType: ReturnType;\n};\n\n/**\n * A symbol for accessing the name of a {@link FunctionReference} at runtime.\n */\nconst functionName = Symbol.for(\"functionName\");\n\n/**\n * Get the name of a function from a {@link FunctionReference}.\n *\n * The name is a string like \"myDir/myModule:myFunction\". If the exported name\n * of the function is `\"default\"`, the function name is omitted\n * (e.g. \"myDir/myModule\").\n *\n * @param functionReference - A {@link FunctionReference} to get the name of.\n * @returns A string of the function's name.\n *\n * @public\n */\nexport function getFunctionName(\n  functionReference: AnyFunctionReference\n): string {\n  // Both a legacy thing and also a convenience for interactive use:\n  // the types won't check but a string is always allowed at runtime.\n  if (typeof functionReference === \"string\") return functionReference;\n\n  // Two different runtime values for FunctionReference implement this\n  // interface: api objects returned from `createApi()` and standalone\n  // function reference objects returned from makeFunctionReference.\n  const name = (functionReference as any)[functionName];\n  if (!name) {\n    throw new Error(`${functionReference as any} is not a functionReference`);\n  }\n  return name;\n}\n\n/**\n * FunctionReferences generally come from generated code, but in custom clients\n * it may be useful to be able to build one manually.\n *\n * Real function references are empty objects at runtime, but the same interface\n * can be implemented with an object for tests and clients which don't use\n * code generation.\n *\n * @param name - The identifier of the function. E.g. `path/to/file:functionName`\n * @public\n */\nexport function makeFunctionReference<\n  type extends FunctionType,\n  args extends DefaultFunctionArgs = any,\n  ret = any\n>(name: string): FunctionReference<type, \"public\", args, ret> {\n  return { [functionName]: name } as unknown as FunctionReference<\n    type,\n    \"public\",\n    args,\n    ret\n  >;\n}\n\n/**\n * Create a runtime API object that implements {@link AnyApi}.\n *\n * This allows accessing any path regardless of what directories, modules,\n * or functions are defined.\n *\n * @param pathParts - The path to the current node in the API.\n * @returns An {@link AnyApi}\n * @public\n */\nfunction createApi(pathParts: string[] = []): AnyApi {\n  const handler: ProxyHandler<object> = {\n    get(_, prop: string | symbol) {\n      if (typeof prop === \"string\") {\n        const newParts = [...pathParts, prop];\n        return createApi(newParts);\n      } else if (prop === functionName) {\n        if (pathParts.length < 2) {\n          const found = [\"api\", ...pathParts].join(\".\");\n          throw new Error(\n            `API path is expected to be of the form \\`api.moduleName.functionName\\`. Found: \\`${found}\\``\n          );\n        }\n        const path = pathParts.slice(0, -1).join(\"/\");\n        const exportName = pathParts[pathParts.length - 1];\n        if (exportName === \"default\") {\n          return path;\n        } else {\n          return path + \":\" + exportName;\n        }\n      } else if (prop === Symbol.toStringTag) {\n        return \"FunctionReference\";\n      } else {\n        return undefined;\n      }\n    },\n  };\n\n  return new Proxy({}, handler);\n}\n\n/**\n * Given an export from a module, convert it to a {@link FunctionReference}\n * if it is a Convex function.\n */\nexport type FunctionReferenceFromExport<Export> =\n  Export extends RegisteredQuery<infer Visibility, infer Args, infer Output>\n    ? FunctionReference<\"query\", Visibility, Args, ConvertReturnType<Output>>\n    : Export extends RegisteredMutation<\n        infer Visibility,\n        infer Args,\n        infer Output\n      >\n    ? FunctionReference<\"mutation\", Visibility, Args, ConvertReturnType<Output>>\n    : Export extends RegisteredAction<\n        infer Visibility,\n        infer Args,\n        infer Output\n      >\n    ? FunctionReference<\"action\", Visibility, Args, ConvertReturnType<Output>>\n    : never;\n\n/**\n * Given a module, convert all the Convex functions into\n * {@link FunctionReference}s and remove the other exports.\n *\n * BE CAREFUL WHEN EDITING THIS!\n *\n * This is written carefully to preserve jumping to function definitions using\n * cmd+click. If you edit it, please test that cmd+click still works.\n */\ntype FunctionReferencesInModule<Module extends Record<string, any>> = {\n  -readonly [ExportName in keyof Module as Module[ExportName][\"isConvexFunction\"] extends true\n    ? ExportName\n    : never]: FunctionReferenceFromExport<Module[ExportName]>;\n};\n\n/**\n * Given a path to a module and it's type, generate an API type for this module.\n *\n * This is a nested object according to the module's path.\n */\ntype ApiForModule<\n  ModulePath extends string,\n  Module extends object\n> = ModulePath extends `${infer First}/${infer Second}`\n  ? {\n      [_ in First]: ApiForModule<Second, Module>;\n    }\n  : { [_ in ModulePath]: FunctionReferencesInModule<Module> };\n\n/**\n * Given the types of all modules in the `convex/` directory, construct the type\n * of `api`.\n *\n * `api` is a utility for constructing {@link FunctionReference}s.\n *\n * @typeParam AllModules - A type mapping module paths (like `\"dir/myModule\"`) to\n * the types of the modules.\n * @public\n */\nexport type ApiFromModules<AllModules extends Record<string, object>> =\n  FilterApi<\n    ApiFromModulesAllowEmptyNodes<AllModules>,\n    FunctionReference<any, any, any, any>\n  >;\n\ntype ApiFromModulesAllowEmptyNodes<AllModules extends Record<string, object>> =\n  ExpandModulesAndDirs<\n    UnionToIntersection<\n      {\n        [ModulePath in keyof AllModules]: ApiForModule<\n          ModulePath & string,\n          AllModules[ModulePath]\n        >;\n      }[keyof AllModules]\n    >\n  >;\n\n/**\n * @public\n *\n * Filter a Convex deployment api object for functions which meet criteria,\n * for example all public queries.\n */\nexport type FilterApi<API, Predicate> = Expand<{\n  [mod in keyof API as API[mod] extends Predicate\n    ? mod\n    : API[mod] extends FunctionReference<any, any, any, any>\n    ? never\n    : FilterApi<API[mod], Predicate> extends Record<string, never>\n    ? never\n    : mod]: API[mod] extends Predicate\n    ? API[mod]\n    : FilterApi<API[mod], Predicate>;\n}>;\n\n/**\n * Given an api of type API and a FunctionReference subtype, return an api object\n * containing only the function references that match.\n *\n * ```ts\n * const q = filterApi<typeof api, FunctionReference<\"query\">>(api)\n * ```\n *\n * @public\n */\nexport function filterApi<API, Predicate>(api: API): FilterApi<API, Predicate> {\n  return api as any;\n}\n\n// These just* API filter helpers require no type parameters so are useable from JavaScript.\n/** @public */\nexport function justInternal<API>(\n  api: API\n): FilterApi<API, FunctionReference<any, \"internal\", any, any>> {\n  return api as any;\n}\n\n/** @public */\nexport function justPublic<API>(\n  api: API\n): FilterApi<API, FunctionReference<any, \"public\", any, any>> {\n  return api as any;\n}\n\n/** @public */\nexport function justQueries<API>(\n  api: API\n): FilterApi<API, FunctionReference<\"query\", any, any, any>> {\n  return api as any;\n}\n\n/** @public */\nexport function justMutations<API>(\n  api: API\n): FilterApi<API, FunctionReference<\"mutation\", any, any, any>> {\n  return api as any;\n}\n\n/** @public */\nexport function justActions<API>(\n  api: API\n): FilterApi<API, FunctionReference<\"action\", any, any, any>> {\n  return api as any;\n}\n\n/** @public */\nexport function justPaginatedQueries<API>(\n  api: API\n): FilterApi<\n  API,\n  FunctionReference<\n    \"query\",\n    any,\n    { paginationOpts: PaginationOptions },\n    PaginationResult<any>\n  >\n> {\n  return api as any;\n}\n\n/** @public */\nexport function justSchedulable<API>(\n  api: API\n): FilterApi<API, FunctionReference<\"mutation\" | \"action\", any, any, any>> {\n  return api as any;\n}\n\n/**\n * Like {@link Expand}, this simplifies how TypeScript displays object types.\n * The differences are:\n * 1. This version is recursive.\n * 2. This stops recursing when it hits a {@link FunctionReference}.\n */\ntype ExpandModulesAndDirs<ObjectType> = ObjectType extends AnyFunctionReference\n  ? ObjectType\n  : {\n      [Key in keyof ObjectType]: ExpandModulesAndDirs<ObjectType[Key]>;\n    };\n\n/**\n * A {@link FunctionReference} of any type and any visibility with any\n * arguments and any return type.\n *\n * @public\n */\nexport type AnyFunctionReference = FunctionReference<any, any>;\n\ntype AnyModuleDirOrFunc = {\n  [key: string]: AnyModuleDirOrFunc;\n} & AnyFunctionReference;\n\n/**\n * The type that Convex api objects extend. If you were writing an api from\n * scratch it should extend this type.\n *\n * @public\n */\nexport type AnyApi = Record<string, Record<string, AnyModuleDirOrFunc>>;\n\n/**\n * Recursive partial API, useful for defining a subset of an API when mocking\n * or building custom api objects.\n *\n * @public\n */\nexport type PartialApi<API> = {\n  [mod in keyof API]?: API[mod] extends FunctionReference<any, any, any, any>\n    ? API[mod]\n    : PartialApi<API[mod]>;\n};\n\n/**\n * A utility for constructing {@link FunctionReference}s in projects that\n * are not using code generation.\n *\n * You can create a reference to a function like:\n * ```js\n * const reference = anyApi.myModule.myFunction;\n * ```\n *\n * This supports accessing any path regardless of what directories and modules\n * are in your project. All function references are typed as\n * {@link AnyFunctionReference}.\n *\n *\n * If you're using code generation, use `api` from `convex/_generated/api`\n * instead. It will be more type-safe and produce better auto-complete\n * in your editor.\n *\n * @public\n */\nexport const anyApi: AnyApi = createApi() as any;\n\n/**\n * Given a {@link FunctionReference}, get the return type of the function.\n *\n * This is represented as an object mapping argument names to values.\n * @public\n */\nexport type FunctionArgs<FuncRef extends AnyFunctionReference> =\n  FuncRef[\"_args\"];\n\n/**\n * A tuple type of the (maybe optional) arguments to `FuncRef`.\n *\n * This type is used to make methods involving arguments type safe while allowing\n * skipping the arguments for functions that don't require arguments.\n *\n * @public\n */\nexport type OptionalRestArgs<FuncRef extends AnyFunctionReference> =\n  FuncRef[\"_args\"] extends EmptyObject\n    ? [args?: EmptyObject]\n    : [args: FuncRef[\"_args\"]];\n\n/**\n * A tuple type of the (maybe optional) arguments to `FuncRef`, followed by an options\n * object of type `Options`.\n *\n * This type is used to make methods like `useQuery` type-safe while allowing\n * 1. Skipping arguments for functions that don't require arguments.\n * 2. Skipping the options object.\n * @public\n */\nexport type ArgsAndOptions<\n  FuncRef extends AnyFunctionReference,\n  Options\n> = FuncRef[\"_args\"] extends EmptyObject\n  ? [args?: EmptyObject, options?: Options]\n  : [args: FuncRef[\"_args\"], options?: Options];\n\n/**\n * Given a {@link FunctionReference}, get the return type of the function.\n *\n * @public\n */\nexport type FunctionReturnType<FuncRef extends AnyFunctionReference> =\n  FuncRef[\"_returnType\"];\n\ntype UndefinedToNull<T> = T extends void ? null : T;\n\n/**\n * Convert the return type of a function to it's client-facing format.\n *\n * This means:\n * - Converting `undefined` and `void` to `null`\n * - Removing all `Promise` wrappers\n */\nexport type ConvertReturnType<T> = UndefinedToNull<Awaited<T>>;\n", "import type { Value } from \"../values/value.js\";\n\n/**\n * Validate that the arguments to a Convex function are an object, defaulting\n * `undefined` to `{}`.\n */\nexport function parseArgs(\n  args: Record<string, Value> | undefined\n): Record<string, Value> {\n  if (args === undefined) {\n    return {};\n  }\n  if (!isSimpleObject(args)) {\n    throw new Error(\n      `The arguments to a Convex function must be an object. Received: ${\n        args as any\n      }`\n    );\n  }\n  return args;\n}\n\nexport function validateDeploymentUrl(deploymentUrl: string) {\n  // Don't use things like `new URL(deploymentUrl).hostname` since these aren't\n  // supported by React Native's JS environment\n  if (typeof deploymentUrl === \"undefined\") {\n    throw new Error(\n      `Client created with undefined deployment address. If you used an environment variable, check that it's set.`\n    );\n  }\n  if (typeof deploymentUrl !== \"string\") {\n    throw new Error(\n      `Invalid deployment address: found ${deploymentUrl as any}\".`\n    );\n  }\n  if (\n    !(deploymentUrl.startsWith(\"http:\") || deploymentUrl.startsWith(\"https:\"))\n  ) {\n    throw new Error(\n      `Invalid deployment address: Must start with \"https://\" or \"http://\". Found \"${deploymentUrl}\".`\n    );\n  }\n\n  // Skip validation on localhost because it's for internal Convex development.\n  if (\n    deploymentUrl.indexOf(\"127.0.0.1\") !== -1 ||\n    deploymentUrl.indexOf(\"localhost\") !== -1\n  ) {\n    return;\n  }\n\n  if (!deploymentUrl.endsWith(\".convex.cloud\")) {\n    throw new Error(\n      `Invalid deployment address: Must end with \".convex.cloud\". Found \"${deploymentUrl}\".`\n    );\n  }\n}\n\n/**\n * Check whether a value is a plain old JavaScript object.\n */\nexport function isSimpleObject(value: unknown) {\n  const isObject = typeof value === \"object\";\n  const prototype = Object.getPrototypeOf(value);\n  const isSimple =\n    prototype === null ||\n    prototype === Object.prototype ||\n    // Objects generated from other contexts (e.g. across Node.js `vm` modules) will not satisfy the previous\n    // conditions but are still simple objects.\n    prototype?.constructor?.name === \"Object\";\n  return isObject && isSimple;\n}\n", "/* eslint-disable no-var */\n\n/*\nhttps://github.com/beatgammit/base64-js/blob/88957c9943c7e2a0f03cdf73e71d579e433627d3/index.js\nCopyright (c) 2014 Jameson Little\nThe MIT License (MIT)\n*/\n\n// Vendored because this library has no ESM build, and some environments\n// (SvelteKit) are happiest when all dependencies are ESM.\n\nvar lookup: string[] = [];\nvar revLookup: number[] = [];\nvar Arr = Uint8Array;\n\nvar code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup[\"-\".charCodeAt(0)] = 62;\nrevLookup[\"_\".charCodeAt(0)] = 63;\n\nfunction getLens(b64: string) {\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error(\"Invalid string. Length must be a multiple of 4\");\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf(\"=\");\n  if (validLen === -1) validLen = len;\n\n  var placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4);\n\n  return [validLen, placeHoldersLen];\n}\n\n// base64 is 4/3 + up to two characters of the original data\n/** @public */\nexport function byteLength(b64: string): number {\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;\n}\n\nfunction _byteLength(_b64: string, validLen: number, placeHoldersLen: number) {\n  return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;\n}\n\n/** @public */\nexport function toByteArray(b64: string): Uint8Array {\n  var tmp;\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n\n  var curByte = 0;\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n\n  var i;\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = (tmp >> 16) & 0xff;\n    arr[curByte++] = (tmp >> 8) & 0xff;\n    arr[curByte++] = tmp & 0xff;\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4);\n    arr[curByte++] = tmp & 0xff;\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2);\n    arr[curByte++] = (tmp >> 8) & 0xff;\n    arr[curByte++] = tmp & 0xff;\n  }\n\n  return arr;\n}\n\nfunction tripletToBase64(num: number) {\n  return (\n    lookup[(num >> 18) & 0x3f] +\n    lookup[(num >> 12) & 0x3f] +\n    lookup[(num >> 6) & 0x3f] +\n    lookup[num & 0x3f]\n  );\n}\n\nfunction encodeChunk(uint8: Uint8Array, start: number, end: number) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xff0000) +\n      ((uint8[i + 1] << 8) & 0xff00) +\n      (uint8[i + 2] & 0xff);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join(\"\");\n}\n\n/** @public */\nexport function fromByteArray(uint8: Uint8Array): string {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(\n      encodeChunk(\n        uint8,\n        i,\n        i + maxChunkLength > len2 ? len2 : i + maxChunkLength\n      )\n    );\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f] + \"==\");\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push(\n      lookup[tmp >> 10] +\n        lookup[(tmp >> 4) & 0x3f] +\n        lookup[(tmp << 2) & 0x3f] +\n        \"=\"\n    );\n  }\n\n  return parts.join(\"\");\n}\n", "/**\n * Utilities for working with values stored in Convex.\n *\n * You can see the full set of supported types at\n * [Types](https://docs.convex.dev/using/types).\n * @module\n */\nimport * as Base64 from \"./base64.js\";\nimport { isSimpleObject } from \"../common/index.js\";\n\nconst LITTLE_ENDIAN = true;\n// This code is used by code that may not have bigint literals.\nconst MIN_INT64 = BigInt(\"-9223372036854775808\");\nconst MAX_INT64 = BigInt(\"9223372036854775807\");\nconst ZERO = BigInt(\"0\");\nconst EIGHT = BigInt(\"8\");\nconst TWOFIFTYSIX = BigInt(\"256\");\n\n/**\n * The type of JavaScript values serializable to JSON.\n *\n * @public\n */\nexport type JSONValue =\n  | null\n  | boolean\n  | number\n  | string\n  | JSONValue[]\n  | { [key: string]: JSONValue };\n\n/**\n * An identifier for a document in Convex.\n *\n * Convex documents are uniquely identified by their `Id`, which is accessible\n * on the `_id` field. To learn more, see [Document IDs](https://docs.convex.dev/database/document-ids).\n *\n * Documents can be loaded using `db.get(id)` in query and mutation functions.\n *\n * IDs are base 32 encoded strings which are URL safe.\n *\n * IDs are just strings at runtime, but this type can be used to distinguish them from other\n * strings at compile time.\n *\n * If you're using code generation, use the `Id` type generated for your data model in\n * `convex/_generated/dataModel.d.ts`.\n *\n * @typeParam TableName - A string literal type of the table name (like \"users\").\n *\n * @public\n */\nexport type Id<TableName extends string> = string & { __tableName: TableName };\n\n/**\n * A value supported by Convex.\n *\n * Values can be:\n * - stored inside of documents.\n * - used as arguments and return types to queries and mutation functions.\n *\n * You can see the full set of supported types at\n * [Types](https://docs.convex.dev/using/types).\n *\n * @public\n */\nexport type Value =\n  | null\n  | bigint\n  | number\n  | boolean\n  | string\n  | ArrayBuffer\n  | Value[]\n  | { [key: string]: undefined | Value };\n\n/**\n * The types of {@link Value} that can be used to represent numbers.\n *\n * @public\n */\nexport type NumericValue = bigint | number;\n\nfunction isSpecial(n: number) {\n  return Number.isNaN(n) || !Number.isFinite(n) || Object.is(n, -0);\n}\n\nexport function slowBigIntToBase64(value: bigint): string {\n  // the conversion is easy if we pretend it's unsigned\n  if (value < ZERO) {\n    value -= MIN_INT64 + MIN_INT64;\n  }\n  let hex = value.toString(16);\n  if (hex.length % 2 === 1) hex = \"0\" + hex;\n\n  const bytes = new Uint8Array(new ArrayBuffer(8));\n  let i = 0;\n  for (const hexByte of hex.match(/.{2}/g)!.reverse()) {\n    bytes.set([parseInt(hexByte, 16)], i++);\n    value >>= EIGHT;\n  }\n  return Base64.fromByteArray(bytes);\n}\n\nexport function slowBase64ToBigInt(encoded: string): bigint {\n  const integerBytes = Base64.toByteArray(encoded);\n  if (integerBytes.byteLength !== 8) {\n    throw new Error(\n      `Received ${integerBytes.byteLength} bytes, expected 8 for $integer`\n    );\n  }\n  let value = ZERO;\n  let power = ZERO;\n  for (const byte of integerBytes) {\n    value += BigInt(byte) * TWOFIFTYSIX ** power;\n    power++;\n  }\n  if (value > MAX_INT64) {\n    value += MIN_INT64 + MIN_INT64;\n  }\n  return value;\n}\n\nexport function modernBigIntToBase64(value: bigint): string {\n  if (value < MIN_INT64 || MAX_INT64 < value) {\n    throw new Error(\n      `BigInt ${value} does not fit into a 64-bit signed integer.`\n    );\n  }\n  const buffer = new ArrayBuffer(8);\n  new DataView(buffer).setBigInt64(0, value, true);\n  return Base64.fromByteArray(new Uint8Array(buffer));\n}\n\nexport function modernBase64ToBigInt(encoded: string): bigint {\n  const integerBytes = Base64.toByteArray(encoded);\n  if (integerBytes.byteLength !== 8) {\n    throw new Error(\n      `Received ${integerBytes.byteLength} bytes, expected 8 for $integer`\n    );\n  }\n  const intBytesView = new DataView(integerBytes.buffer);\n  return intBytesView.getBigInt64(0, true);\n}\n\n// Fall back to a slower version on Safari 14 which lacks these APIs.\nexport const bigIntToBase64 = (DataView.prototype as any).setBigInt64\n  ? modernBigIntToBase64\n  : slowBigIntToBase64;\nexport const base64ToBigInt = (DataView.prototype as any).getBigInt64\n  ? modernBase64ToBigInt\n  : slowBase64ToBigInt;\n\nconst MAX_IDENTIFIER_LEN = 1024;\n\nfunction validateObjectField(k: string) {\n  if (k.length === 0) {\n    throw new Error(\"Empty field names are disallowed.\");\n  }\n  if (k.length > MAX_IDENTIFIER_LEN) {\n    throw new Error(\n      `Field name ${k} exceeds maximum field name length ${MAX_IDENTIFIER_LEN}.`\n    );\n  }\n  if (k.startsWith(\"$\")) {\n    throw new Error(`Field name ${k} starts with a '$', which is reserved.`);\n  }\n  for (let i = 0; i < k.length; i += 1) {\n    const charCode = k.charCodeAt(i);\n    // Non-control ASCII characters\n    if (charCode < 32 || charCode >= 127) {\n      throw new Error(\n        `Field name ${k} has invalid character '${k[i]}': Field names can only contain non-control ASCII characters`\n      );\n    }\n  }\n}\n\nfunction jsonToConvexInternal(\n  value: JSONValue,\n  allowMapsAndSets: boolean\n): Value {\n  if (value === null) {\n    return value;\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"number\") {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if (Array.isArray(value)) {\n    return value.map((value) => jsonToConvexInternal(value, allowMapsAndSets));\n  }\n  if (typeof value !== \"object\") {\n    throw new Error(`Unexpected type of ${value as any}`);\n  }\n  const entries = Object.entries(value);\n  if (entries.length === 1) {\n    const key = entries[0][0];\n    if (key === \"$bytes\") {\n      if (typeof value.$bytes !== \"string\") {\n        throw new Error(`Malformed $bytes field on ${value as any}`);\n      }\n      return Base64.toByteArray(value.$bytes).buffer;\n    }\n    if (key === \"$integer\") {\n      if (typeof value.$integer !== \"string\") {\n        throw new Error(`Malformed $integer field on ${value as any}`);\n      }\n      return base64ToBigInt(value.$integer);\n    }\n    if (key === \"$float\") {\n      if (typeof value.$float !== \"string\") {\n        throw new Error(`Malformed $float field on ${value as any}`);\n      }\n      const floatBytes = Base64.toByteArray(value.$float);\n      if (floatBytes.byteLength !== 8) {\n        throw new Error(\n          `Received ${floatBytes.byteLength} bytes, expected 8 for $float`\n        );\n      }\n      const floatBytesView = new DataView(floatBytes.buffer);\n      const float = floatBytesView.getFloat64(0, LITTLE_ENDIAN);\n      if (!isSpecial(float)) {\n        throw new Error(`Float ${float} should be encoded as a number`);\n      }\n      return float;\n    }\n    if (key === \"$set\") {\n      if (!Array.isArray(value.$set)) {\n        throw new Error(`Malformed $set field on ${value as any}`);\n      }\n      if (!allowMapsAndSets) {\n        throw new Error(\n          `Received a Set which is no longer supported as a Convex type, with values: ${value.$set.join(\n            \", \"\n          )}.`\n        );\n      }\n      return new Set(\n        value.$set.map((value) => jsonToConvexInternal(value, allowMapsAndSets))\n      ) as any;\n    }\n    if (key === \"$map\") {\n      if (!Array.isArray(value.$map)) {\n        throw new Error(`Malformed $map field on ${value as any}`);\n      }\n      if (!allowMapsAndSets) {\n        throw new Error(\n          `Received a Map which is no longer supported as a Convex type, with entries: ${value.$map.join(\n            \", \"\n          )}.`\n        );\n      }\n      const map = new Map();\n      for (const pair of value.$map) {\n        if (!Array.isArray(pair) || pair.length !== 2) {\n          throw new Error(`Malformed pair in $map ${value as any}`);\n        }\n        const k = jsonToConvexInternal(pair[0], allowMapsAndSets);\n        const v = jsonToConvexInternal(pair[1], allowMapsAndSets);\n        map.set(k, v);\n      }\n      return map as any;\n    }\n  }\n  const out: { [key: string]: Value } = {};\n  for (const [k, v] of Object.entries(value)) {\n    validateObjectField(k);\n    out[k] = jsonToConvexInternal(v, allowMapsAndSets);\n  }\n  return out;\n}\n\n/**\n * Parse a Convex value from its JSON representation.\n *\n * This function will deserialize serialized Int64s to `BigInt`s, Bytes to `ArrayBuffer`s etc.\n *\n * To learn more about Convex values, see [Types](https://docs.convex.dev/using/types).\n *\n * @param value - The JSON representation of a Convex value previously created with {@link convexToJson}.\n * @returns The JavaScript representation of the Convex value.\n *\n * @public\n */\nexport function jsonToConvex(\n  value: JSONValue,\n  /** @internal */\n  allowMapsAndSets = false\n): Value {\n  return jsonToConvexInternal(value, allowMapsAndSets);\n}\n\nexport function stringifyValueForError(value: any) {\n  return JSON.stringify(value, (_key, value) => {\n    if (value === undefined) {\n      // By default `JSON.stringify` converts undefined, functions, symbols,\n      // Infinity, and NaN to null which produces a confusing error message.\n      // We deal with `undefined` specifically because it's the most common.\n      // Ideally we'd use a pretty-printing library that prints `undefined`\n      // (no quotes), but it might not be worth the bundle size cost.\n      return \"undefined\";\n    }\n    if (typeof value === \"bigint\") {\n      // `JSON.stringify` throws on bigints by default.\n      return `${value.toString()}n`;\n    }\n    return value;\n  });\n}\n\nfunction convexToJsonInternal(\n  value: Value,\n  originalValue: Value,\n  context: string,\n  includeTopLevelUndefined: boolean,\n  // Used to support old versions that allowed Maps and Sets\n  allowMapsAndSets: boolean\n): JSONValue {\n  if (value === undefined) {\n    const contextText =\n      context &&\n      ` (present at path ${context} in original object ${stringifyValueForError(\n        originalValue\n      )})`;\n    throw new Error(\n      `undefined is not a valid Convex value${contextText}. To learn about Convex's supported types, see https://docs.convex.dev/using/types.`\n    );\n  }\n  if (value === null) {\n    return value;\n  }\n  if (typeof value === \"bigint\") {\n    if (value < MIN_INT64 || MAX_INT64 < value) {\n      throw new Error(\n        `BigInt ${value} does not fit into a 64-bit signed integer.`\n      );\n    }\n    return { $integer: bigIntToBase64(value) };\n  }\n  if (typeof value === \"number\") {\n    if (isSpecial(value)) {\n      const buffer = new ArrayBuffer(8);\n      new DataView(buffer).setFloat64(0, value, LITTLE_ENDIAN);\n      return { $float: Base64.fromByteArray(new Uint8Array(buffer)) };\n    } else {\n      return value;\n    }\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if (value instanceof ArrayBuffer) {\n    return { $bytes: Base64.fromByteArray(new Uint8Array(value)) };\n  }\n  if (Array.isArray(value)) {\n    return value.map((value, i) =>\n      convexToJsonInternal(\n        value,\n        originalValue,\n        context + `[${i}]`,\n        false,\n        allowMapsAndSets\n      )\n    );\n  }\n  if (value instanceof Set) {\n    if (!allowMapsAndSets) {\n      throw new Error(\n        errorMessageForUnsupportedType(\n          context,\n          \"Set\",\n          [...value],\n          originalValue\n        )\n      );\n    }\n    return {\n      $set: [...value].map((value, i) =>\n        convexToJsonInternal(\n          value,\n          originalValue,\n          context + `.keys()[${i}]`,\n          false,\n          allowMapsAndSets\n        )\n      ),\n    };\n  }\n  if (value instanceof Map) {\n    if (!allowMapsAndSets) {\n      throw new Error(\n        errorMessageForUnsupportedType(\n          context,\n          \"Map\",\n          [...value],\n          originalValue\n        )\n      );\n    }\n    return {\n      $map: [...value].map(([k, v], i) => {\n        const jsonKey = convexToJsonInternal(\n          k,\n          originalValue,\n          context + `.keys()[${i}]`,\n          false,\n          allowMapsAndSets\n        );\n        const jsonValue = convexToJsonInternal(\n          v,\n          originalValue,\n          context + `.values()[${i}]`,\n          false,\n          allowMapsAndSets\n        );\n        return [jsonKey, jsonValue];\n      }),\n    };\n  }\n\n  if (!isSimpleObject(value)) {\n    const theType = value?.constructor?.name;\n    const typeName = theType ? `${theType} ` : \"\";\n    throw new Error(\n      errorMessageForUnsupportedType(context, typeName, value, originalValue)\n    );\n  }\n\n  const out: { [key: string]: JSONValue } = {};\n  const entries = Object.entries(value);\n  entries.sort(([k1, _v1], [k2, _v2]) => (k1 === k2 ? 0 : k1 < k2 ? -1 : 1));\n  for (const [k, v] of entries) {\n    if (v !== undefined) {\n      validateObjectField(k);\n      out[k] = convexToJsonInternal(\n        v,\n        originalValue,\n        context + `.${k}`,\n        false,\n        allowMapsAndSets\n      );\n    } else if (includeTopLevelUndefined) {\n      validateObjectField(k);\n      out[k] = convexOrUndefinedToJsonInternal(\n        v,\n        originalValue,\n        context + `.${k}`\n      );\n    }\n  }\n  return out;\n}\n\nfunction errorMessageForUnsupportedType(\n  context: string,\n  typeName: string,\n  value: any,\n  originalValue: any\n) {\n  if (context) {\n    return `${typeName}${stringifyValueForError(\n      value\n    )} is not a supported Convex type (present at path ${context} in original object ${stringifyValueForError(\n      originalValue\n    )}). To learn about Convex's supported types, see https://docs.convex.dev/using/types.`;\n  } else {\n    return `${typeName}${stringifyValueForError(\n      value\n    )} is not a supported Convex type.`;\n  }\n}\n\n// convexOrUndefinedToJsonInternal wrapper exists so we can pipe through the\n// `originalValue` and `context` through for better error messaging.\nfunction convexOrUndefinedToJsonInternal(\n  value: Value | undefined,\n  originalValue: Value | undefined,\n  context: string\n): JSONValue {\n  if (value === undefined) {\n    return { $undefined: null };\n  } else {\n    if (originalValue === undefined) {\n      // This should not happen.\n      throw new Error(\n        `Programming error. Current value is ${stringifyValueForError(\n          value\n        )} but original value is undefined`\n      );\n    }\n    return convexToJsonInternal(value, originalValue, context, false, false);\n  }\n}\n\n/**\n * Convert a Convex value to its JSON representation.\n *\n * Use {@link jsonToConvex} to recreate the original value.\n *\n * To learn more about Convex values, see [Types](https://docs.convex.dev/using/types).\n *\n * @param value - A Convex value to convert into JSON.\n * @returns The JSON representation of `value`.\n *\n * @public\n */\nexport function convexToJson(\n  value: Value,\n  /** @internal */\n  allowMapsAndSets = false\n): JSONValue {\n  return convexToJsonInternal(value, value, \"\", false, allowMapsAndSets);\n}\n\n// Convert a Convex value or `undefined` into its JSON representation.\n// `undefined` is used in filters to represent a missing object field.\nexport function convexOrUndefinedToJson(value: Value | undefined): JSONValue {\n  return convexOrUndefinedToJsonInternal(value, value, \"\");\n}\n\n/**\n * Similar to convexToJson but also serializes top level undefined fields\n * using convexOrUndefinedToJson().\n *\n * @param value - A Convex value to convert into JSON.\n * @returns The JSON representation of `value`.\n */\nexport function patchValueToJson(value: Value): JSONValue {\n  return convexToJsonInternal(value, value, \"\", true, false);\n}\n", "import { JSONValue, convexToJson, Id as GenericId } from \"./value.js\";\nimport { Expand } from \"../type_utils.js\";\n\n/**\n * A validator for a Convex value.\n *\n * This should be constructed using the validator builder, {@link v}.\n *\n * This class encapsulates:\n * - The TypeScript type of this value.\n * - Whether this field should be optional if it's included in an object.\n * - The TypeScript type for the set of index field paths that can be used to\n * build indexes on this value.\n * - A JSON representation of the validator.\n * @public\n */\nexport class Validator<\n  TypeScriptType,\n  IsOptional extends boolean = false,\n  FieldPaths extends string = never\n> {\n  readonly type!: TypeScriptType;\n  readonly isOptional!: IsOptional;\n  readonly fieldPaths!: FieldPaths;\n\n  // Property for a bit of nominal type safety.\n  readonly _isValidator: undefined;\n\n  readonly optional: boolean;\n  /**\n   * @internal\n   */\n  readonly json: ValidatorJSON;\n  /**\n   * @internal\n   */\n  constructor(json: ValidatorJSON, optional: boolean) {\n    this.json = json;\n    this.optional = optional;\n  }\n}\n\n/**\n * @internal\n */\nexport type ObjectFieldType = { fieldType: ValidatorJSON; optional: boolean };\n\n/**\n * @internal\n */\nexport type ValidatorJSON =\n  | {\n      type: \"null\";\n    }\n  | { type: \"number\" }\n  | { type: \"bigint\" }\n  | { type: \"boolean\" }\n  | { type: \"string\" }\n  | { type: \"bytes\" }\n  | { type: \"any\" }\n  | {\n      type: \"literal\";\n      value: JSONValue;\n    }\n  | { type: \"id\"; tableName: string }\n  | { type: \"array\"; value: ValidatorJSON }\n  | { type: \"record\"; keys: ValidatorJSON; values: ObjectFieldType }\n  | { type: \"object\"; value: Record<string, ObjectFieldType> }\n  | { type: \"union\"; value: ValidatorJSON[] };\n\n/**\n * The validator builder.\n *\n * This builder allows you to build validators for Convex values.\n *\n * Validators can be used in [schema definitions](https://docs.convex.dev/database/schemas)\n * and as input validators for Convex functions.\n *\n * @public\n */\nexport const v = {\n  id<TableName extends string>(\n    tableName: TableName\n  ): Validator<GenericId<TableName>> {\n    return new Validator({ type: \"id\", tableName }, false);\n  },\n  null(): Validator<null> {\n    return new Validator({ type: \"null\" }, false);\n  },\n  /**\n   * Alias for `v.float64()`\n   */\n  number(): Validator<number> {\n    return new Validator({ type: \"number\" }, false);\n  },\n  float64(): Validator<number> {\n    return new Validator({ type: \"number\" }, false);\n  },\n  /**\n   * @deprecated Use `v.int64()` instead\n   */\n  bigint(): Validator<bigint> {\n    return new Validator({ type: \"bigint\" }, false);\n  },\n  int64(): Validator<bigint> {\n    return new Validator({ type: \"bigint\" }, false);\n  },\n  boolean(): Validator<boolean> {\n    return new Validator({ type: \"boolean\" }, false);\n  },\n  string(): Validator<string> {\n    return new Validator({ type: \"string\" }, false);\n  },\n  bytes(): Validator<ArrayBuffer> {\n    return new Validator({ type: \"bytes\" }, false);\n  },\n  literal<T extends string | number | bigint | boolean>(\n    literal: T\n  ): Validator<T> {\n    const value = convexToJson(literal);\n    return new Validator({ type: \"literal\", value }, false);\n  },\n  array<T>(values: Validator<T, false, any>): Validator<T[]> {\n    return new Validator({ type: \"array\", value: values.json }, false);\n  },\n  object<T extends PropertyValidators>(schema: T): ObjectValidator<T> {\n    return new Validator(\n      {\n        type: \"object\",\n        value: Object.fromEntries(\n          Object.entries(schema).map(([k, v]) => [\n            k,\n            { fieldType: v.json, optional: v.optional },\n          ])\n        ),\n      },\n      false\n    );\n  },\n\n  /** @internal */\n  record<K extends string, ValueValidator extends Validator<any, any, any>>(\n    keys: Validator<K, false, any>,\n    values: ValueValidator\n  ): RecordValidator<K, ValueValidator> {\n    return new Validator(\n      {\n        type: \"record\",\n        keys: keys.json,\n        values: { fieldType: values.json, optional: values.optional },\n      },\n      false\n    );\n  },\n\n  union<\n    T extends [\n      Validator<any, false, any>,\n      Validator<any, false, any>,\n      ...Validator<any, false, any>[]\n    ]\n  >(\n    ...schemaTypes: T\n  ): Validator<T[number][\"type\"], false, T[number][\"fieldPaths\"]> {\n    return new Validator(\n      {\n        type: \"union\",\n        value: schemaTypes.map((t) => t.json),\n      },\n      false\n    );\n  },\n  any(): Validator<any, false, string> {\n    return new Validator({ type: \"any\" }, false);\n  },\n  optional<T extends Validator<any, false, any>>(\n    inner: T\n  ): Validator<T[\"type\"] | undefined, true, T[\"fieldPaths\"]> {\n    return new Validator(inner.json, true) as Validator<\n      T[\"type\"],\n      true,\n      T[\"fieldPaths\"]\n    >;\n  },\n};\n\n/**\n * Validators for each property of an object.\n *\n * This is represented as an object mapping the property name to its\n * {@link Validator}.\n *\n * @public\n */\nexport type PropertyValidators = Record<string, Validator<any, any, any>>;\n\n/**\n * Compute the type of an object from {@link PropertyValidators}.\n *\n * @public\n */\nexport type ObjectType<Validators extends PropertyValidators> = Expand<\n  // Map each key to the corresponding property validator's type making\n  // the optional ones optional.\n  {\n    [Property in OptionalKeys<Validators>]?: Validators[Property][\"type\"];\n  } & {\n    [Property in RequiredKeys<Validators>]: Validators[Property][\"type\"];\n  }\n>;\n\n/**\n * Calculate the type of a {@link Validator} for an object.\n *\n * This is used within the validator builder, {@link v}.\n */\nexport type ObjectValidator<Validators extends PropertyValidators> = Validator<\n  // Compute the TypeScript type this validator refers to.\n  ObjectType<Validators>,\n  false,\n  // Compute the field paths for this validator. For every property in the object,\n  // add on a field path for that property and extend all the field paths in the\n  // validator.\n  {\n    [Property in keyof Validators]:\n      | JoinFieldPaths<Property & string, Validators[Property][\"fieldPaths\"]>\n      | Property;\n  }[keyof Validators] &\n    string\n>;\n\ntype OptionalKeys<\n  PropertyValidators extends Record<string, Validator<any, any, any>>\n> = {\n  [Property in keyof PropertyValidators]: PropertyValidators[Property][\"isOptional\"] extends true\n    ? Property\n    : never;\n}[keyof PropertyValidators];\n\ntype RequiredKeys<\n  PropertyValidators extends Record<string, Validator<any, any, any>>\n> = Exclude<keyof PropertyValidators, OptionalKeys<PropertyValidators>>;\n\n/**\n * Calculate the type of a {@link Validator} for an object that produces indexed types.\n *\n * If the value validator is not optional, it produces a `Record` type, which is an alias\n * for `{[key: K]: V}`.\n *\n * If the value validator is optional, it produces a mapped object type,\n * with optional keys: `{[key in K]?: V}`.\n *\n * This is used within the validator builder, {@link v}.\n */\nexport type RecordValidator<\n  K extends string,\n  ValueValidator extends Validator<any, any, any>\n> = Validator<\n  ValueValidator[\"isOptional\"] extends true\n    ? { [key in K]?: ValueValidator[\"type\"] }\n    : Record<K, ValueValidator[\"type\"]>\n>;\n\n/**\n * Join together two index field paths.\n *\n * This is used within the validator builder, {@link v}.\n * @public\n */\ntype JoinFieldPaths<\n  Start extends string,\n  End extends string\n> = `${Start}.${End}`;\n\n/**\n * Extract a TypeScript type from a validator.\n *\n * Example usage:\n * ```ts\n * const objectSchema = v.object({\n *   property: v.string(),\n * });\n * type MyObject = Infer<typeof objectSchema>; // { property: string }\n * ```\n * @typeParam V - The type of a {@link Validator} constructed with {@link v}.\n *\n * @public\n */\nexport type Infer<V extends Validator<any, any, any>> = V[\"type\"];\n", "import { Value, stringifyValueForError } from \"./value.js\";\n\nconst IDENTIFYING_FIELD = Symbol.for(\"ConvexError\");\n\nexport class ConvexError<TData extends Value> extends Error {\n  name = \"ConvexError\";\n  data: TData;\n  [IDENTIFYING_FIELD] = true;\n\n  constructor(data: TData) {\n    super(typeof data === \"string\" ? data : stringifyValueForError(data));\n    this.data = data;\n  }\n}\n", "export const version = \"1.9.0\";\n"],
  "mappings": "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",
  "names": ["_a", "value", "v", "_a", "v"]
}
